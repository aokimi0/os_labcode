# Lab 5 实验报告

## 练习 3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现

### 1\. fork/exec/wait/exit 的执行流程分析

在 uCore 中，进程控制主要涉及到 `do_fork`, `do_execve`, `do_wait`, `do_exit` 这四个核心函数。它们的执行流程涉及用户态与内核态的切换。

#### (1) fork 创建进程

  * **执行流程：**
    1.  程序在用户态调用 `fork()` 系统调用。
    2.  通过 `ecall` 指令触发 Trap，进入内核态，最终调用 `do_fork` 函数。
    3.  `do_fork` 分配一个新的 `proc_struct` PCB。
    4.  调用 `copy_mm` 复制父进程的内存空间。
    5.  调用 `copy_thread` 复制父进程的 Trapframe 和上下文。关键在于将子进程 Trapframe 中的返回值寄存器 `a0` 设置为 0，而父进程的返回值为子进程 PID。
    6.  将子进程状态设置为 `PROC_RUNNABLE` 并加入就绪队列。
    7.  内核态返回，父进程和子进程分别从 `fork()` 调用处继续执，但在用户态获得的返回值不同。

#### (2) exec 加载新程序

  * **执行流程：**
    1.  用户态调用 `exec()`。
    2.  进入内核态，调用 `do_execve`。
    3.  检查内存空间，如果当前进程拥有内存空间`mm`，则清空并释放，准备加载新程序。
    4.  调用 `load_icode` 加载 ELF 格式的二进制程序。这包括建立新的内存映射、分配栈空间、处理 BSS 段等。
    5.  修改当前进程 Trapframe 中的 `epc` 程序计数器为 ELF 文件的入口地址，重置 `sp` 栈指针为新的用户栈顶。
    6.  `do_execve` 返回，系统执行 `sret` 从内核态返回用户态。此时 CPU 跳转到新程序的入口地址执行，旧程序的上下文完全被替换。

#### (3) wait 等待子进程

  * **执行流程：**
    1.  用户态调用 `wait()`。
    2.  进入内核态，调用 `do_wait`。
    3.  父进程遍历自己的子进程列表。
    4.  如果发现有子进程处于 `PROC_ZOMBIE` 僵尸状态，则回收该子进程的剩余资源，如内核栈、PCB，并获取其退出码，返回用户态。
    5.  如果子进程都在运行，父进程将自己状态设为 `PROC_SLEEPING` 并调用 `schedule`主动放弃 CPU，调用 `schedule`），等待被唤醒。
    6.  当子进程 `exit` 退出时`exit`，会唤醒父进程。

#### (4) exit 进程退出

  * **执行流程：**
    1.  用户态调用 `exit()` 或程序结束。
    2.  进入内核态，调用 `do_exit`。
    3.  释放进程的大部分资源，虚拟内存空间 `mm`，但保留 PCB 和内核栈以便父进程查询。
    4.  将状态设置为 `PROC_ZOMBIE`。
    5.  如果该进程有子进程，将子进程挂载到 `init` 进程 PID 1下，由 `init` 负责回收。
    6.  唤醒父进程。
    7.  调用 `schedule` 调度其他进程执行。
  * **哪些在用户态，哪些在内核态？**

      * **用户态：** 发起系统调用的初始动作，设置参数、执行 `ecall`，以及系统调用返回后的后续逻辑。
      * **内核态：** 资源的分配与回收，如内存、PCB、上下文切换、ELF 解析与加载、进程状态的变更、调度决策。

  * **内核态与用户态程序如何交错执行？**

      * 通过系统调用、中断和异常进行切换。用户程序运行 -\> 触发 Trap (ecall) -\> 硬件保存状态 -\> 内核处理 -\> 内核恢复状态 (sret) -\> 用户程序继续运行。

  * **内核态执行结果如何返回给用户程序？**

      * 通过修改Trapframe中断帧中的寄存器。
      * 返回值通常保存在 `a0` 寄存器中。内核在处理完系统调用后，将结果写入当前进程 Trapframe 的 `a0` 处。当执行 `sret` 返回用户态时，硬件会将 Trapframe 中的值恢复到 CPU 寄存器，用户程序便能读取到返回值。

### 2\. 用户态进程的执行状态生命周期图

```text
       (alloc_proc)          (scheduler)
[UNINIT] --------> [RUNNABLE] <--------> [RUNNING]
                      ^    |                 |
                      |    |                 | (do_exit)
            (wakeup)  |    | (do_wait)       |
                      |    v                 v
                   [SLEEPING]            [ZOMBIE]
                                             |
                                             | (parent waits)
                                             v
                                          [DEAD]
```


## 扩展练习 Challenge2 

**问题：说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？**

### 1\. 用户程序被加载到内存的时机

用户程序是随内核镜像Kernel Image一起被加载到内存中的。

  * **具体机制：** 实验构建系统（Makefile）会将编译好的用户程序二进制代码链接到内核的可执行文件中（通常通过链接脚本或宏定义 `macros.S` 中的 `.incbin` 等指令）。
  * **物理位置：** 当 Bootloader 将 uCore 内核加载到物理内存时，这些用户程序的二进制数据就已经作为内核数据的一部分存在于物理内存中了。
  * **执行时：** 当 `do_execve` 调用 `load_icode` 时，它并不是从磁盘读取文件，而是直接从内存中的某个特定位置（指向该用户程序的指针）拷贝内容建立新的内存映射。

### 2\. 与常用操作系统的区别

| 特性 | uCore | Linux/Windows |
| :--- | :--- | :--- |
| **存储位置** | 编译进内核镜像，常驻物理内存。 | 存储在磁盘的文件系统中。 |
| **加载方式** | 一次性全部存在。`exec` 时从内核数据区映射。 | 按需加载 。`exec` 仅读取头部，执行时通过缺页异常动态从磁盘加载页面。 |


### 3\. 造成这种区别的原因
一方面是为了避免引入复杂的文件系统代码和磁盘 I/O 操作，将用户程序直接嵌入内存是最简单的实现方式，另一方面硬件设施也有限。
